import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as i,f as n}from"./app-297e668d.js";const r={},o=n('<h1 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h1><h2 id="_1-索引的常见模型" tabindex="-1"><a class="header-anchor" href="#_1-索引的常见模型" aria-hidden="true">#</a> 1.索引的常见模型</h2><h3 id="_1-1-哈希表" tabindex="-1"><a class="header-anchor" href="#_1-1-哈希表" aria-hidden="true">#</a> 1.1 哈希表</h3><p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p><p>哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。</p><figure><img src="https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210325161959054.png" alt="image-20210325161959054" tabindex="0" loading="lazy"><figcaption>image-20210325161959054</figcaption></figure><h3 id="_1-2-有序数组" tabindex="-1"><a class="header-anchor" href="#_1-2-有序数组" aria-hidden="true">#</a> 1.2 有序数组</h3><p><strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong></p><figure><img src="https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210325170524027.png" alt="image-20210325170524027" tabindex="0" loading="lazy"><figcaption>image-20210325170524027</figcaption></figure><p>这个索引结构支持范围查询。你要查身份证号在 [ID_card_X, ID_card_Y] 区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。</p><p><strong>有序数组索引只适用于静态存储引擎</strong></p><figure><img src="https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210325170627777.png" alt="image-20210325170627777" tabindex="0" loading="lazy"><figcaption>image-20210325170627777</figcaption></figure><h3 id="_1-3-二叉树索引" tabindex="-1"><a class="header-anchor" href="#_1-3-二叉树索引" aria-hidden="true">#</a> 1.3 二叉树索引</h3><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</p><p>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。</p><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><h3 id="_1-4-innodb-的索引模型" tabindex="-1"><a class="header-anchor" href="#_1-4-innodb-的索引模型" aria-hidden="true">#</a> 1.4 InnoDB 的索引模型</h3><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p><p><strong>每一个索引在 InnoDB 里面对应一棵 B+ 树。</strong></p><figure><img src="https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210325173045780.png" alt="image-20210325173045780" tabindex="0" loading="lazy"><figcaption>image-20210325173045780</figcaption></figure><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p>',23),t=[o];function c(g,d){return e(),i("div",null,t)}const p=a(r,[["render",c],["__file","3.数据库索引.html.vue"]]);export{p as default};
